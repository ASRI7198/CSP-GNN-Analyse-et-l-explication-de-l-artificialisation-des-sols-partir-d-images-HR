# 1 - Segmentation et classification avec QGIS

Ce d√©p√¥t d√©crit **l‚Äô√©tape ‚ÄúSegmentation & Classification‚Äù** d‚Äôun projet d‚Äôoccupation des sols sous **QGIS**.  
Il documente les donn√©es attendues, le flux de travail pas-√†-pas, **les variables calcul√©es**, **les classes √©tudi√©es**, ainsi que **les m√©thodes et r√©sultats** utilis√©s dans notre √©tude.

---

## ‚úÖ Pr√©requis

- **QGIS 3.28+** (ou version plus r√©cente)
- Plugins recommand√©s (via *Extensions > Installer/G√©rer les extensions‚Ä¶*):
  - **Orfeo Toolbox (OTB)** ‚Äî segmentation et classification avanc√©es  
    > N√©cessite l‚Äôinstallation d‚ÄôOTB puis la configuration dans *Traitements > Options > Fournisseurs > Orfeo Toolbox*.
  - **Semi-Automatic Classification Plugin (SCP)** *(optionnel)* ‚Äî classification et √©valuation
  - **SAGA/GRASS** *(optionnels)* ‚Äî alternatives pour certaines √©tapes (segmentation, post-traitements)
- Donn√©es d‚Äôimagerie (ex. Sentinel-2, orthophotos‚Ä¶), **g√©or√©f√©renc√©es** et **projet√©es** dans un CRS m√©trique appropri√© (UTM local).

---

## üìÅ Structure du projet

```
Images/                      # Imagerie d‚Äôentr√©e (GeoTIFF, JP2, etc.)
Vecteur Classes/             # Polygones d‚Äôentra√Ænement (√©tiquet√©s), ex. classes_train.gpkg
Classes/                     # Style, tables de l√©gende, codes classe (.csv, .qml)
Segmentation/                # R√©sultats de segmentation (raster ou vecteur)
Classification/              # Rasters classifi√©s, cartes finales, masques post-trait√©s
Statistiques/                # Rapports: matrices de confusion, scores (OA, Kappa, F1), graphes
Segmentation et Classification.qgz   # Fichier projet QGIS pr√©configur√©
```

### Convention de nommage (recommand√©e)
- `Images/scene_YYYYMMDD.tif`
- `Vecteur Classes/classes_train.gpkg` (couche: `train_polys`)
- `Segmentation/segments_YYYYMMDD.gpkg` (couche: `segments`)
- `Classification/classif_RF700_YYYYMMDD.tif`
- `Statistiques/report_classif_YYYYMMDD.md`

---

## üß≠ Flux de travail (pas-√†-pas)

### 1) Pr√©parer l‚Äôimagerie (dossier `Images/`)
1. D√©poser les rasters d‚Äôentr√©e (bandes empil√©es si possible).  
2. V√©rifier le **CRS** et reprojeter si besoin (*Raster > Projections > Reprojeter‚Ä¶*).  
3. (Optionnel) D√©couper √† l‚Äôemprise d‚Äô√©tude (*Traitements > GDAL > Extraction > D√©couper un raster par emprise*).

**R√©sultat attendu :** `Images/scene_*.tif`

---

### 2) Cr√©er les classes d‚Äôentra√Ænement (dossier `Vecteur Classes/`)
1. Cr√©er un GeoPackage `classes_train.gpkg` contenant une couche polygonale `train_polys`.  
2. Champs recommand√©s :
   - `class_id` (entier) ‚Äî code num√©rique de classe
   - `class_name` (texte) ‚Äî libell√© (ex. `Zones urbanis√©es`, `Eaux continentales`, etc.)
   - `fold` (entier, optionnel) ‚Äî 0 = train, 1 = validation (pour l‚Äô√©valuation)
3. Num√©riser des **polygones homog√®nes** par classe couvrant la variabilit√© spectrale.

**R√©sultat attendu :** `Vecteur Classes/classes_train.gpkg`

---

### 3) Segmentation (dossier `Segmentation/`)

**Contexte de l‚Äô√©tude**  
Nous avons appliqu√© la segmentation sur une s√©rie d‚Äôimages satellitaires √† l‚Äôaide du plugin **Orfeo Toolbox (OTB)**, int√©gr√© √† **QGIS**. Quatre m√©thodes propos√©es par OTB ont √©t√© test√©es :

- **Mean Shift** : regroupe les pixels similaires en fonction de leur couleur et de leur proximit√© spatiale. Utile pour d√©tecter des objets bien d√©finis.  
- **Connected Components (CC)** : identifie les zones de pixels connect√©s ayant la m√™me valeur. M√©thode simple mais sensible au bruit.  
- **Watershed** : interpr√®te l‚Äôimage comme une surface topographique et s√©pare les r√©gions selon le principe des bassins versants. Utile pour distinguer des objets coll√©s.  
- **Profiles** : utilise les variations d‚Äôintensit√© (profils radiom√©triques) pour segmenter l‚Äôimage. Adapt√©e aux structures lin√©aires comme les routes ou les rivi√®res.

**M√©thode retenue** : **Mean Shift**, en raison de ses performances plus robustes pour la d√©tection des objets dans nos donn√©es.

**Export** : Les segments sont vectoris√©s en polygones (`segments_*.gpkg`) pour l‚Äôanalyse g√©ospatiale.

---

### 4) Variables calcul√©es par segment (g√©om√©triques & contextuelles)

Apr√®s la segmentation, nous avons calcul√© un ensemble d‚Äô**attributs g√©om√©triques et contextuels** via l‚Äôoutil **‚ÄúCalculer les statistiques‚Äù** de QGIS et des traitements associ√©s.  
Les variables retenues sont list√©es ci‚Äëdessous :

| Variable                 | Description                                                                 | Unit√© typique                 |
|--------------------------|-----------------------------------------------------------------------------|-------------------------------|
| `DN`                     | Identifiant unique du polygone                                              | ‚Äî (identifiant)               |
| `year`                   | Ann√©e d‚Äôacquisition                                                         | Ann√©e (ex. 2019, 2024)        |
| `Aire`                   | Surface totale du polygone                                                  | m¬≤                            |
| `Perimeter`              | Longueur totale du contour du polygone                                      | m                             |
| `Largeur`                | Largeur maximale du polygone                                                | m                             |
| `Hauteur`                | Hauteur maximale du polygone                                                | m                             |
| `Rectangularity`         | Mesure de la ‚Äúrectangularit√©‚Äù                                               | Sans unit√© (ratio)            |
| `Elongation`             | Mesure de l‚Äô√©tirement du polygone                                           | Sans unit√© (ratio)            |
| `Indice_Miller`          | Indice de compacit√© (Miller)                                                | Sans unit√© (ratio)            |
| `Multipolygone`          | G√©om√©trie multipolygone                                                     | ‚Äî (objet g√©om√©trique)         |
| `Centroid`               | Centre de gravit√© g√©om√©trique                                               | Coordonn√©es (x, y)            |
| `Nbr_Voisins`            | Nombre de polygones voisins adjacents                                       | Nombre entier                 |
| `Surf_Voisins`           | Somme des surfaces des polygones voisins                                    | m¬≤                            |
| `Pix_Mean`               | Moyenne des valeurs de pixels contenus dans le polygone                     | Valeur num√©rique              |
| `Pix_Std`                | √âcart type des valeurs de pixels contenus dans le polygone                  | Valeur num√©rique              |
| `Pix_Var`                | Variance des valeurs de pixels contenus dans le polygone                    | Valeur num√©rique              |

> Remarque : adaptez les noms de champs √† vos couches (ex. `seg_id`, `mean_B2`, etc.) si vous extrayez des statistiques zonales par bande.

**R√©sultat attendu :** `Segmentation/segments_*.gpkg` enrichi avec ces variables.

---

### 5) Liste des classes √©tudi√©es (Niveau 1 ‚Äî 2019, Montpellier M√©diterran√©e M√©tropole)

Le jeu d‚Äôoccupation du sol (1994‚Äì2023, 48 classes au niveau 4) a √©t√© **agr√©g√© au niveau 1** pour notre analyse 2019. Les **8 classes** retenues sont :

| # | Nom de classe | Description |
|---|---------------|-------------|
| 1 | **Chantiers** | Zones de construction active (b√¢timents, infrastructures en travaux) |
| 2 | **Eaux continentales** | Plans d‚Äôeau naturels ou artificiels (lacs, rivi√®res, r√©servoirs) |
| 3 | **Espaces ouverts, sans ou avec peu de v√©g√©tation** | Terrains non b√¢tis √† v√©g√©tation rare (sols nus, parkings, terrains vagues) |
| 4 | **For√™ts** | Zones bois√©es √† couvert v√©g√©tal dense |
| 5 | **R√©seaux routier et ferroviaire et espaces associ√©s** | Infrastructures de transport et leurs abords (routes, gares, talus) |
| 6 | **Zones agricoles** | Terres cultiv√©es, p√¢turages, vergers |
| 7 | **Zones de loisirs** | Espaces r√©cr√©atifs (parcs, stades, terrains de golf) |
| 8 | **Zones urbanis√©es** | B√¢timents, quartiers r√©sidentiels/commerciaux, zones industrielles |

Placez votre table de correspondance (`Classes/classes.csv`) pour lier `class_id`, `class_name` et une **couleur** QGIS.

---

### 6) Pr√©parer l‚Äô√©chantillonnage d‚Äôapprentissage
Associer les **√©tiquettes** (`class_id`) aux segments :

1. *Vecteur > Outils de g√©otraitement > Intersection* entre `train_polys` et `segments`.  
2. (Option) Dissoudre par `seg_id` en gardant la **classe majoritaire** si plusieurs classes touchent le m√™me segment.  
3. Conserver deux ensembles si souhait√© : `fold=0` (train) et `fold=1` (validation).

**R√©sultat attendu :** table d‚Äô√©chantillons avec descripteurs + `class_id`.

---

### 7) Classification supervis√©e (OTB/SCP)

La classification repose sur l‚Äôimage segment√©e et un jeu d‚Äôentra√Ænement annot√©. Apr√®s extraction des caract√©ristiques, un **mod√®le** (p. ex. **Random Forest** ou **SVM**) est **entra√Æn√©** puis **appliqu√©** pour produire une carte classifi√©e (par segment ou par pixel).

**Mod√®les test√©s et performances (‚Üë = meilleur)**

| Mod√®le                     | Accuracy | Pr√©cision | Rappel | F1-score |
|---------------------------|---------:|----------:|-------:|---------:|
| **Random Forest (700 arbres)** | **0,81** | **0,78** | **0,81** | **0,79** |
| Random Forest (100 arbres) | 0,551 | 0,54 | 0,55 | 0,52 |
| Boosting                   | 0,364 | 0,13 | 0,36 | 0,18 |
| KNN                        | 0,364 | 0,13 | 0,36 | 0,18 |
| Naive Bayes                | 0,223 | 0,27 | 0,22 | 0,21 |
| SVM                        | 0,213 | 0,28 | 0,21 | 0,19 |

**Meilleur mod√®le** : **Random Forest (700 arbres)** ‚Äî performances les plus √©lev√©es et segmentation/classification visuellement coh√©rentes.

**Sorties attendues :**
- `Classification/classif_RF700_*.tif` (raster de classes)
- `Statistiques/` (matrices de confusion, courbes, rapport)

---

### 8) Post-traitements (optionnels)
- **Filtre de majorit√© / lissage** pour r√©duire le bruit sel-poivre
- **Morphologie** (ou *r.neighbors* via GRASS)
- **Vectorisation** des classes d‚Äôint√©r√™t (*Raster > Conversion > Polygones √† partir de raster*)

**R√©sultat attendu :** produits cartographiques lisibles (raster + vecteur).

---

## üìä √âvaluation & illustrations

- **√âchantillons de validation** : polygones/points ind√©pendants (`fold=1`).  
- **M√©triques** : Accuracy, Pr√©cision, Rappel, **F1‚Äëscore** (cf. tableau ci‚Äëdessus).  
- **Illustrations** (d√©posez vos figures ici et mettez √† jour les chemins) :  
  - `Segmentation/seg1.jpg`, `Segmentation/seg2.jpg` ‚Äî exemples de **segmentation Mean Shift**  
  - `Classification/image-segmenter.jpg`, `Classification/image-colore.jpg` ‚Äî **(a) Segmentation / (b) Classification**  
  - `Classes/classes.jpg` ‚Äî l√©gende des classes

---

## üé® Styles & l√©gende (dossier `Classes/`)

- `classes.csv` : mapping `class_id,class_name,color` pour **8 classes niveau 1** ci‚Äëdessus.  
- Style QGIS (`.qml`) appliqu√© au raster de classification pour une palette coh√©rente.

---

## üöÄ D√©marrage rapide

1. **Ouvrir** `Segmentation et Classification.qgz` dans QGIS.  
2. V√©rifier les **chemins relatifs**.
3. Charger `Images/scene_*.tif` et `Vecteur Classes/classes_train.gpkg`.  
4. Lancer la **segmentation** (OTB > *Mean Shift*, m√©thode retenue), extraire les **variables**, **entra√Æner** le mod√®le (RF700) et **classer**.  
5. Exporter les **rapports** dans `Statistiques/` et la carte finale dans `Classification/`.

---

## üß™ Conseils pratiques

- **√âquilibrer** les √©chantillons par classe (surface/nb de segments).
- Ajuster la **granularit√©** des segments pour l‚Äô√©chelle des objets.
- S√©parer **entra√Ænement** et **validation** (champ `fold`).
- Sauvegarder mod√®les et param√®tres pour la **reproductibilit√©**.

---

## üìÑ Licence / Donn√©es

- Donn√©es d‚Äôoccupation du sol : **Montpellier M√©diterran√©e M√©tropole (1994‚Äì2023)**.  
  Pour cette √©tude, **8 classes niveau 1** ont √©t√© utilis√©es pour **2019**.  
- Indiquez ici la licence des donn√©es et du code (ex. MIT, CC‚ÄëBY‚ÄëSA).

---

## üîß D√©pannage

- OTB non d√©tect√© : configurez le chemin dans *Traitements > Options > Orfeo Toolbox*.
- Segmentation trop fine/grossi√®re : ajustez les param√®tres Mean‚ÄëShift (ou testez CC/Watershed/Profiles).
- Classes confondues : ajoutez des **√©chantillons**, des **indices** (NDVI/NDBI/NDWI), ou testez un autre algorithme.



<!-- ===== Hero / Header ===== -->
<div align="center">

# 2 - Extraction et Analyse de Graphes Spatio‚ÄêTemporels

</div>

<p align="center">
  <img alt="divider" src="https://img.shields.io/badge/Python-%3E%3D3.8-informational" />
  <img alt="geopandas" src="https://img.shields.io/badge/GeoPandas-usage-blue" />
  <img alt="networkx" src="https://img.shields.io/badge/NetworkX-graphs-blue" />
  <img alt="shapely" src="https://img.shields.io/badge/Shapely-geometry-blue" />
  <img alt="pandas" src="https://img.shields.io/badge/Pandas-dataframe-blue" />
  <img alt="matplotlib" src="https://img.shields.io/badge/Matplotlib-visualization-blue" />
</p>

---

<details>
<summary><strong>üìë Sommaire</strong></summary>

- [2 - Extraction et Analyse de Graphes Spatio‚ÄêTemporels](#2---extraction-et-analyse-de-graphes-spatio-temporels)
  - [Arborescence du projet](#arborescence-du-projet)
  - [Installation et d√©pendances](#installation-et-d√©pendances)
  - [Description des fichiers](#description-des-fichiers)
  - [Stockage des donn√©es et r√©sultats](#stockage-des-donn√©es-et-r√©sultats)
  - [Usage](#usage)
</details>

---

Cette √©tape vise √† :

- Pr√©parer et convertir des donn√©es g√©ographiques (formats GeoPackage) vers des CSV exploitables.
- Cr√©er des graphes spatiaux √† partir de caract√©ristiques de polygones (aires, p√©rim√®tres, etc.).
- G√©n√©rer des graphes spatio‚Äêtemporels en combinant deux graphes spatiaux successifs et en d√©tectant des relations (scission, fusion, d√©rivation, continuation).
- Exporter et lire des graphes en format GraphML.
- Calculer et afficher des statistiques sur les graphes produits.

---

## Arborescence du projet

```
‚îú‚îÄ‚îÄ function/                   # Code m√©tier principal
‚îÇ   ‚îú‚îÄ‚îÄ Functions.py            # Cr√©ation de n≈ìuds et graphes spatiaux / spatio‚Äêtemporels
‚îÇ   ‚îî‚îÄ‚îÄ Function_GST.py         # Affichage et calcul de statistiques sur les graphes
‚îú‚îÄ‚îÄ relation/                   # D√©tection des relations et pr√©paration des donn√©es
‚îÇ   ‚îú‚îÄ‚îÄ Relation_spasital.py    # Adjacence spatiale (Shapely touches)
‚îÇ   ‚îú‚îÄ‚îÄ Relation_temporelle.py  # Scission et Fusion entre deux dates
‚îÇ   ‚îú‚îÄ‚îÄ Relations_filiation.py  # Continuation et D√©rivation
‚îÇ   ‚îú‚îÄ‚îÄ Data_preparation.py     # Conversion GeoPackage ‚Üí CSV
‚îÇ   ‚îî‚îÄ‚îÄ Noeud.py                # Classe Noeud et calcul d‚Äôattributs
‚îú‚îÄ‚îÄ pretreatment/               # Orchestration et pr√©traitement global
‚îÇ   ‚îú‚îÄ‚îÄ Main.py                 # Script principal cr√©ant et stockant les graphes
‚îÇ   ‚îî‚îÄ‚îÄ test_GST.py             # (exemple de test ou de script statistique additionnel)
‚îú‚îÄ‚îÄ Graphes spatiaux/           # GraphML produits pour chaque date (local)
‚îú‚îÄ‚îÄ Graphes Spatio-Temporelles/ # GraphML produits pour les transitions (local)
‚îî‚îÄ‚îÄ Statistiques/               # Donn√©es et scripts statistiques (stock√©s sur Google Drive)
```

---

## Installation et d√©pendances

1. **Python >= 3.8**
2. Installer les packages requis :
   ```bash
   pip install geopandas networkx shapely pandas matplotlib
   ```

---

## Description des fichiers

### 1. Data_preparation.py

- **To_Json(path, nams)** : lit un GeoPackage via GeoPandas et exporte le contenu en CSV (*Grabels*\*.csv\*).
- **Bloc principal** : it√®re sur une liste de suffixes de dates, convertit chacun des fichiers GeoPackage en CSV.

### 2. Noeud.py

- **Classe `Noeud`** :
  - Attributs : DN, year, Aire, Perimeter, Largeur, Hauteur, Rectangularity, I_Miller, centroid, mean, std, variance, classe.
  - M√©thodes :
    - `Polygon_Elongation()` : calcule l‚Äô√©longation (rapport c√¥t√© long / c√¥t√© court).
    - `nombre_voisins_adjacents(multipolygones)` : compte les polygones adjacents (touchant).
    - `surface_cumulee_voisins(multipolygones)` : somme des surfaces des voisins adjacents.
    - `compute_all(multipolygones)` : ex√©cute toutes les m√©thodes de calcul d‚Äôattributs.

### 3. Relation_spasital.py

- **`Adjacence(graphe)`** :
  - Pour chaque paire de n≈ìuds, teste si leurs g√©om√©tries se touchent (Shapely `touches`).
  - Ajoute une ar√™te avec `relation='Adjacence'` si c‚Äôest le cas.

### 4. Relation_temporelle.py

- **Utilitaires** :
  - `getDistance(attr1, attr2)` : distance euclidienne entre deux centro√Ødes (*string* ‚Üí coordonn√©es).
  - `max_polygon_length(attr)` : diam√®tre maximal du MultiPolygon.
  - `Mon_function(attr1, attr2)` : score de similarit√© moyenne sur les attributs `{Aire, Perimeter, Rectangularity, I_Miller}`.
- **Relations** :
  - `Scission(G1, G2)` : lie n≈ìuds de G1 √† G2 si plusieurs fragments d‚Äôun m√™me polygone original apparaissent (score 0<‚Ä¶‚â§0.9 et somme de surfaces proche √† 5 %).
  - `Fusion(G1, G2)` : analogue √† `Scission` mais pour plusieurs n≈ìuds de G1 fusionnant en un de G2.
- **`Copy_Nodes(G1, G2)`** : initialise un MultiDiGraph contenant tous les n≈ìuds annot√©s par ann√©e.

### 5. Relations_filiation.py

- M√™me structure d‚Äôutilitaires (`getDistance`, `max_polygon_length`, `Mon_function`).
- **`Continuation(G1, G2)`** : relie si un m√™me polygone persiste d‚Äôune date √† l‚Äôautre (score >0.9).
- **`D√©rivation(G1, G2)`** : relie si un polygone se transforme en plusieurs (score 0‚Äì0.9).
- **`get_attributes(attr)`** : affiche √† l‚Äô√©cran les attributs d‚Äôun n≈ìud (debug).
- **`Copy_Nodes(G1, G2)`** : identique √† celle de `Relation_temporelle.py`, pour initialiser les n≈ìuds.

### 6. Functions.py

- **Chargement de CSV** : fonctions (`Geometry`, `Classes`, `DN`, `Area`, `Perimeter`, `Compacit√©`, `Width`, `Height`, `Rectangularity`, `mean`, `std`, `variance`) qui renvoient des listes issues des colonnes du CSV.
- **`Year(path)`** : extrait l‚Äôann√©e et le mois du nom de fichier (*Grabels_XX_YYYY.csv*).
- **`Create_Noeuds(path)`** :
  1. Lit le CSV et cr√©e un `Noeud` par ligne.
  2. Calcule automatiquement les attributs (*compute_all*).
- **`Create_Graph(noeuds)`** :
  - Construit un graph NetworkX non-orient√© avec chaque `Noeud` comme n≈ìud annot√© de ses attributs.
  - Applique `Relation_spasital.Adjacence` pour ajouter les ar√™tes spatiales.
- **`Create_Graphe_spatio_temporel(G1, G2)`** :
  1. G√©n√®re un MultiDiGraph initialis√© avec tous les n≈ìuds de G1 et G2 (cl√©=(node_id, year)).
  2. Copie les ar√™tes spatiales de G1, G2 en les annotant de la date.
  3. Applique `Scission`, `Fusion`, `D√©rivation`, `Continuation` pour relier G1‚áÑG2.
- **`get_last_year` / `get_first_year`** : utilitaires pour extraire la plage de dates.
- **`Create_Graphe_spatio_temporel_2(G_st1, G_st2)`** : variante qui ne consid√®re que les entit√©s de transition entre derni√®re ann√©e de G_st1 et premi√®re ann√©e de G_st2.
- **`Stocker_Graph_GraphML(G, name, index)`** :
  - Exporte le graphe en GraphML (XML) dans `Graphes spatiaux/` (index=0) ou `Graphes Spatio-Temporelles/` (index=1).
- **`Read_GraphML(path, name)`** : lit un fichier `.graphml.xml` et retourne un objet NetworkX.

### 7. Main.py

- D√©finit des listes de suffixes de dates (`nams`).
- **`traitement_Creat_GS()`** : pour chaque CSV, cr√©e le graphe spatial et l‚Äôexporte.
- **`traitement_Read_GS()`** : charge tous les graphes spatiaux export√©s.
- **`traitement_Read_GST(nams_st)`** : charge tous les graphes spatio-temporels.
- **`traitement_Creat_GST()`** : g√©n√®re et stocke les premiers graphes spatio-temporels √† partir de paires successives de graphes spatiaux.
- **`traitement_Creat_GST_2(nams_st)`** : g√©n√®re des graphes spatio-temporels plus larges (encha√Ænements de plusieurs p√©riodes).
- **`__main__`** : ex√©cute la cha√Æne compl√®te de cr√©ation et de stockage.

---

### Stockage des donn√©es et r√©sultats

1. Les graphiques spatiaux et spatio‚Äêtemporels, ainsi que les exports statistiques, sont accessibles sur ce Google Drive :
https://drive.google.com/drive/folders/1yym5qWhOCaro-jY7DkBYTQwLnL5jsQqN?usp=sharing
2. Les r√©pertoires Graphes spatiaux/ et Graphes Spatio-Temporelles/ contiennent les fichiers .graphml.xml g√©n√©r√©s localement.
3. Le dossier visualisation/ contient les r√©sultats de visualisation (plots et cartes) pour chaque graphe spatial.

## Usage

1. **Pr√©parez** vos GeoPackage dans le dossier `Statistiques/`.
2. **Lancez** :
   ```bash
   python Data_preparation.py
   python Main.py
   ```
3. **Consultez** les fichiers GraphML g√©n√©r√©s dans :
   - `Graphes spatiaux/`
   - `Graphes Spatio-Temporelles/`
4. **Affichez** les statistiques via :
   ```python
   from Function_GST import afficher_statistiques_gst
   afficher_statistiques_gst(votre_graphe_st)
   ```


# 3 - D√©tection de motifs d'artificialisation

Cette √©tape impl√©mente la d√©tection de motifs d'artificialisation √† partir d'un graphe spatio-temporel √† l'aide d'un Graphe Neuronal (GNN) : m√©thode Multi\_SPminer.

## Structure du projet

Le d√©p√¥t est organis√© en deux phases principales¬†:

### 1. Embedding\_phase

Ce dossier contient les sous-modules suivants¬†:

* **generate\_data**¬†: g√©n√®re les donn√©es de sous-graphes¬†A et¬†B ainsi que leurs labels, en utilisant un nombre de hops (K-hop) et une taille maximale de graphe.
* **MGCN**¬†: d√©finition de l‚Äôarchitecture du mod√®le MGCN et de la fonction de perte associ√©e.
* **main**¬†: script principal (`main.py`) qui permet de lancer le programme, avec deux modes¬†:

  * `train`¬†: pour l‚Äôentra√Ænement du mod√®le.
  * `test`¬†: pour l‚Äô√©valuation et l‚Äôanalyse.
* **embeddings\_analysis**¬†: calcul et statistiques des embeddings produits.
* **evaluation**¬†: √©valuation des embeddings par r√©gression logistique.
* **visualisation**¬†: g√©n√©ration des courbes de perte (train et validation) par epoch.

### 2. Search\_phase

Ce dossier contient¬†:

* **search.py**¬†: fonctions pour l‚Äôextraction des motifs d‚Äôartificialisation.
* **search\_test.py**¬†: script pour appliquer ces fonctions sur le graphe spatio-temporel.
* **update\_json.py**¬†: utilitaire pour modifier ou enrichir les fichiers JSON de r√©sultats (ajout d‚Äôattributs, r√©glages des param√®tres, etc.).

## Donn√©es

Les donn√©es produites par `generate_data` sont volumineuses (entre 2‚ÄØGo et 38‚ÄØGo).

Le graphe spatio-temporel complet et les r√©sultats des motifs d‚Äôartificialisation (ensemble de fichiers JSON, un par configuration de param√®tres et donn√©es paires) sont disponibles dans le dossier partag√©¬†Drive¬†: https://drive.google.com/drive/folders/1yym5qWhOCaro-jY7DkBYTQwLnL5jsQqN?usp=sharing.

## Pr√©requis et installation

1. Cr√©ez et activez un environnement Python :

   ```bash
   conda create -n mon_env python=3.10
   conda activate mon_env
   ```

## Notes compl√©mentaires

* J‚Äôai d√©velopp√© l‚Äôint√©gralit√© du code en m‚Äôinspirant de plusieurs d√©p√¥ts GitHub existants¬†; l‚Äôarchitecture et les fonctionnalit√©s ont √©t√© con√ßues et optimis√©es sp√©cifiquement pour ce projet.




